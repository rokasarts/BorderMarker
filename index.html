<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Wind Border Marker</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
<meta name="author" content="Rokasarts">
<link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ðŸ’¥</text></svg>">
<link rel="alternate icon" type="image/png" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ðŸ’¥</text></svg>">
<link rel="apple-touch-icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ðŸ’¥</text></svg>">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous">
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/suncalc@1.9.0/suncalc.js"></script>
<style>
  :root{
    --color-white:#fff; --color-black:#1a1a1a; --color-red:#ff3b30;
    --color-green:#10b981; --color-blue:#3b82f6;
    --color-gray-50:#f9fafb; --color-gray-100:#f3f4f6; --color-gray-200:#e5e7eb; --color-gray-300:#d1d5db; --color-gray-500:#6b7280;
    --color-blue-50:#eff6ff; --color-blue-200:#bfdbfe; --color-blue-700:#1e40af;

    --wind-calm:#10b981; --wind-moderate:#3b82f6; --wind-strong:#ef4444;

    --card-bg:var(--color-white); --text:var(--color-black); --text-secondary:var(--color-gray-500);
    --border:var(--color-gray-200); --shadow:0 10px 30px rgba(0,0,0,.12);
    --radius:16px; --panel-padding:20px; --control-height:40px;

    --night-bg:#0a1929;
  }

  *{margin:0;padding:0;box-sizing:border-box}
  html,body,#map{height:100vh;height:100dvh;font-family:Inter,-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,sans-serif;color:var(--text);-webkit-font-smoothing:antialiased}
  body{background:var(--night-bg);overflow-x:hidden}
  #map{background:var(--night-bg);position:relative;z-index:1;touch-action:pan-x pan-y pinch-zoom}
  
  @media (max-width:768px){
    html,body,#map{height:100vh;height:100dvh}
    body{overflow:hidden}
  }

  .info-panel{
    position:absolute;bottom:106px;left:16px;z-index:10;width:340px;background:var(--card-bg);
    border-radius:var(--radius);box-shadow:var(--shadow);padding:0;transition:all .3s ease;overflow:hidden
  }
  .info-panel.collapsed .info-content{max-height:0;padding:0 var(--panel-padding)}
  .info-panel.collapsed .info-toggle{border-bottom:none;border-radius:var(--radius)}
  .info-content{
    padding:var(--panel-padding);max-height:500px;overflow:hidden;transition:max-height .3s ease,padding .3s ease;
    text-align:left;
  }
  .info-toggle{padding:var(--panel-padding);display:flex;align-items:center;gap:10px;cursor:pointer;border-bottom:1px solid var(--border);transition:background .2s}
  .info-toggle:hover{background:var(--color-gray-50);border-radius:var(--radius) var(--radius) 0 0}
  .toggle-arrow{margin-left:auto;transition:transform .3s;font-size:12px;color:var(--text-secondary)}
  .info-panel.collapsed .toggle-arrow{transform:rotate(180deg)}
  .logo-w{width:44px;height:44px;background:var(--text);color:#fff;border-radius:10px;display:flex;align-items:center;justify-content:center;font-size:24px;font-weight:700;flex-shrink:0}
  .logo-text{font-size:18px;font-weight:700;line-height:1.3}
  .description{
    font-size:13px;line-height:1.5;color:var(--text-secondary);
    margin-bottom:20px;text-align:left;
  }

  .legend,.wind-legend{display:flex;align-items:center;gap:8px;font-size:13px}
  .legend{margin-bottom:12px}
  .wind-legend{margin-bottom:20px}
  .legend-line{width:50px;height:5px;background:var(--color-red);border-radius:3px;box-shadow:0 0 6px rgba(255,59,48,.5)}
  .wind-gradient{width:50px;height:5px;border-radius:3px;background:linear-gradient(to right,var(--wind-calm),var(--wind-moderate),var(--wind-strong))}

  .disclaimer{background:var(--color-blue-50);border:1px solid var(--color-blue-200);border-radius:12px;margin-bottom:20px;overflow:hidden;cursor:pointer;transition:background .2s}
  .disclaimer:hover{background:#e0f2fe}
  .disclaimer-header{display:flex;align-items:center;gap:6px;font-size:12px;font-weight:600;color:var(--color-blue-700);padding:14px}
  .disclaimer-text{font-size:11px;line-height:1.5;color:var(--color-blue-700);max-height:0;overflow:hidden;padding:0 14px;transition:max-height .3s ease,padding .3s ease}
  .disclaimer.open .disclaimer-text{max-height:200px;padding:0 14px 14px 14px}
  .disclaimer-arrow{margin-left:auto;transition:transform .3s}
  .disclaimer.open .disclaimer-arrow{transform:rotate(180deg)}
  .credits{font-size:11px;color:var(--text-secondary);line-height:1.6;text-align:left;}
  .credits strong{color:var(--text);font-weight:600;}

  .control-bar{
    position:absolute;bottom:16px;left:16px;right:16px;z-index:10;background:var(--card-bg);border-radius:var(--radius);
    box-shadow:var(--shadow);padding:var(--panel-padding);display:flex;align-items:center;gap:16px;flex-wrap:wrap
  }
  .control-group{display:flex;align-items:center;gap:12px}
  .time-control{display:flex;align-items:center;gap:12px;flex:1;height:var(--control-height)}

  select{
    height:var(--control-height);padding:0 36px 0 12px;border:1px solid var(--border);border-radius:8px;font-size:14px;font-family:inherit;background:#fff;
    cursor:pointer;min-width:140px;appearance:none;transition:border-color .2s;
    background-image:url("data:image/svg+xml,%3Csvg width='12' height='8' viewBox='0 0 12 8' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M1 1.5L6 6.5L11 1.5' stroke='%236b7280' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'/%3E%3C/svg%3E");
    background-repeat:no-repeat;background-position:right 12px center
  }
  select:hover{border-color:var(--color-gray-300)}
  select:focus{outline:none;border-color:var(--text)}

  .time-display{
    font-size:14px;font-weight:600;width:72px;white-space:nowrap;text-align:center;
    height:var(--control-height);display:flex;align-items:center;justify-content:center;border-radius:8px;padding:0 12px;border:1px solid var(--border)
  }

  input[type=range]{
    position:absolute;top:0;left:0;width:100%;height:6px;border-radius:3px;background:transparent;
    outline:none;appearance:none;z-index:2;
  }

  .slider-container{
    flex:1;position:relative;height:6px;background:var(--border);border-radius:3px;
  }
  
  .loading-bar{
    position:absolute;top:0;left:0;height:100%;width:0%;
    background:var(--color-red);border-radius:3px;pointer-events:none;
    opacity:0;transition:width .4s ease-out, background-color .6s ease, opacity .6s ease;
    z-index:1;
  }
  
  .slider-container.loading .loading-bar{
    opacity:1;
  }
  
  .slider-container.loaded .loading-bar{
    background:var(--color-gray-300);
    opacity:.7;
  }

  input[type=range]::-webkit-slider-thumb{
    appearance:none;width:18px;height:18px;border-radius:50%;
    background:var(--color-red);cursor:pointer;box-shadow:0 2px 6px rgba(255,59,48,.4);
    transition:transform .2s;position:relative;z-index:10;
    margin-top:-6px;
  }
  input[type=range]::-moz-range-thumb{
    width:18px;height:18px;border-radius:50%;background:var(--color-red);
    cursor:pointer;border:none;box-shadow:0 2px 6px rgba(255,59,48,.4);
    transition:transform .2s;position:relative;z-index:10;
  }
  input[type=range]::-webkit-slider-runnable-track{
    width:100%;height:6px;cursor:pointer;background:transparent;border-radius:3px;
  }
  input[type=range]::-moz-range-track{
    width:100%;height:6px;cursor:pointer;background:transparent;border-radius:3px;
  }
  input[type=range]:hover::-webkit-slider-thumb{transform:scale(1.1)}
  input[type=range]:hover::-moz-range-thumb{transform:scale(1.1)}

  button{height:var(--control-height);padding:0 18px;background:var(--text);color:#fff;border:none;border-radius:8px;font-size:14px;font-weight:600;font-family:inherit;cursor:pointer;white-space:nowrap;transition:all .2s;min-width:100px}
  button:hover:not(:disabled){opacity:.9;transform:translateY(-1px)}
  button:active:not(:disabled){transform:translateY(0)}
  button.live-active{background:var(--color-green)}
  button:disabled{opacity:.5;cursor:not-allowed;transform:none}

  .emoji-pin{transform:translate(-50%,-92%);font-size:36px;text-shadow:0 2px 4px rgba(0,0,0,.25);cursor:pointer;transition:transform .3s ease}

  .wind-tooltip{position:absolute;background:rgba(26,26,26,.95);color:#fff;padding:6px 10px;border-radius:6px;font-size:12px;font-weight:600;pointer-events:none;z-index:20;white-space:nowrap;display:none}

  .offline-hint{
    position:fixed;left:50%;top:16px;transform:translateX(-50%);
    background:#fff3cd;border:1px solid #ffe69c;color:#664d03;
    padding:10px 14px;border-radius:12px;box-shadow:var(--shadow);z-index:1000;
    font-size:13px;font-weight:600;max-width:90vw;text-align:center;display:none
  }

  @media (max-width:1024px){.info-panel{width:300px}.control-group select{flex:1;min-width:0}}
  @media (max-width:768px){
    :root{--panel-padding:16px;--control-height:44px}
    .info-panel{position:fixed;bottom:auto;top:16px;left:16px;right:16px;width:auto;max-width:100%}
    .control-bar{flex-direction:column;align-items:stretch;gap:12px;position:fixed;bottom:16px;left:16px;right:16px}
    .control-group{width:100%;gap:12px}
    .time-control{width:100%;gap:12px}
    .control-group select{flex:1;width:auto;font-size:16px}
    button{width:100%;font-size:16px}
    .time-display{align-self:center}
    .logo-w{width:40px;height:40px;font-size:22px}
    .logo-text{font-size:16px}
  }
  @media (max-width:480px){
    :root{--panel-padding:14px;--radius:12px}
    .info-panel{max-height:calc(100vh - 220px);overflow-y:auto}
    .info-content{max-height:none}
    select{padding:0 32px 0 10px;background-position:right 10px center}
    button{padding:0 14px}
  }
</style>
</head>
<body>
<div id="map" aria-label="Map showing wind inflow across country borders"></div>

<div class="wind-tooltip" id="windTooltip" role="status" aria-live="polite"></div>

<div class="info-panel" id="infoPanel" aria-live="polite">
  <div class="info-toggle" id="infoToggle" role="button" tabindex="0" aria-expanded="true" aria-controls="infoContent">
    <div class="logo-w" aria-hidden="true">ðŸŽˆ</div>
    <div class="logo-text">Wind Border Marker</div>
    <span class="toggle-arrow">â–¼</span>
  </div>

  <div class="info-content" id="infoContent">
    <p class="description">Environmental awareness app for real time wind data across country borders.</p>

    <div class="legend">
      <span class="legend-line" aria-hidden="true"></span>
      <span>Wind inflow (outside â†’ inside)</span>
    </div>

    <div class="wind-legend">
      <span class="wind-gradient" aria-hidden="true"></span>
      <span>Wind speed (calm â†’ strong)</span>
    </div>

    <div class="disclaimer" id="disclaimer" role="button" tabindex="0" aria-expanded="false">
      <div class="disclaimer-header">
        <span aria-hidden="true">âš </span>
        <span>DISCLAIMER</span>
        <span class="disclaimer-arrow">â–²</span>
      </div>
      <div class="disclaimer-text">
        This tool uses AI assistance and may contain inaccuracies. Created for educational purposes to raise awareness about cross-border air incursions.
      </div>
    </div>

    <div class="credits">
      <div>Creator: <a href="https://www.linkedin.com/in/rokasarts/" target="_blank" rel="noopener noreferrer">Rokasarts</a></div>
      <div>Wind: Open-Meteo / met.no</div>
      <div>Map: OpenStreetMap</div>
      <div>Boundaries: OSM/Nominatim</div>
    </div>
  </div>
</div>

<div class="control-bar" role="group" aria-label="Time and country controls">
  <button id="liveBtn" aria-label="Jump to live time">Live view</button>

  <div class="control-group">
    <select id="countrySelect" aria-label="Select country">
      <option value="Lithuania">ðŸ‡±ðŸ‡¹ Lithuania</option>
      <option value="Latvia">ðŸ‡±ðŸ‡» Latvia</option>
      <option value="Estonia">ðŸ‡ªðŸ‡ª Estonia</option>
      <option value="Poland">ðŸ‡µðŸ‡± Poland</option>
      <option value="Ukraine">ðŸ‡ºðŸ‡¦ Ukraine</option>
    </select>
    <select id="dateSelect" aria-label="Select date"></select>
  </div>

  <div class="time-control">
    <span class="time-display" id="timeDisplay" aria-live="polite">12:00</span>
    <div class="slider-container" id="sliderContainer">
      <div class="loading-bar" id="loadingBar"></div>
      <input type="range" min="0" max="23" step="1" value="0" id="hourSlider" aria-label="Hour of day">
    </div>
  </div>
</div>

<div id="offlineHint" class="offline-hint" role="status" aria-live="polite"></div>

<script>
(async () => {

/* ==================== CONFIG ==================== */
const CONFIG = {
  FORECAST_DAYS: 6,
  DRAW_STEP_KM: 5,
  SAMPLE_FOR_WIND_KM: 40,
  INFLOW_ANGLE_THRESHOLD: 80,
  SIMPLIFY_TOLERANCE_KM: 2.5,
  CONCURRENCY: Math.max(1, Math.min(8, Math.floor((navigator.hardwareConcurrency || 4) / 2))),

  PARTICLE_LINE_WIDTH: 2.6,
  PARTICLE_GLOW: 0.85,
  PARTICLE_PER_SEED: 12,
  PARTICLE_LIFE_MIN: 24,
  PARTICLE_LIFE_MAX: 48,
  SPEED_SCALE: 0.07,
  SPEED_BIAS: 0.5,
  SPEED_CAP: 2.2,

  WIND_CALM_THRESHOLD: 10,
  WIND_MODERATE_THRESHOLD: 30,

  WIND_COLOR_CALM: '#10b981',
  WIND_COLOR_MODERATE: '#3b82f6',
  WIND_COLOR_STRONG: '#ef4444',

  NIGHT_OPACITY_MAX: 20,
  
  USER_AGENT: 'WindBorderMarker/1.0 (Educational Project; Created by Rokasarts)'
};

const COUNTRY_COORDS = {
  'Lithuania': { lat: 55.169, lon: 23.881 },
  'Latvia': { lat: 56.879, lon: 24.603 },
  'Estonia': { lat: 58.595, lon: 25.013 },
  'Poland': { lat: 51.919, lon: 19.145 },
  'Ukraine': { lat: 48.379, lon: 31.165 }
};

/* ==================== DOM ==================== */
const elements = {
  map: document.getElementById('map'),
  hourSlider: document.getElementById('hourSlider'),
  timeDisplay: document.getElementById('timeDisplay'),
  countrySelect: document.getElementById('countrySelect'),
  dateSelect: document.getElementById('dateSelect'),
  liveBtn: document.getElementById('liveBtn'),
  disclaimer: document.getElementById('disclaimer'),
  infoPanel: document.getElementById('infoPanel'),
  infoToggle: document.getElementById('infoToggle'),
  windTooltip: document.getElementById('windTooltip'),
  offlineHint: document.getElementById('offlineHint'),
  sliderContainer: document.getElementById('sliderContainer'),
  loadingBar: document.getElementById('loadingBar')
};

/* ==================== MAP ==================== */
const map = L.map('map', { 
  zoomControl: true,
  tap: true,
  touchZoom: true,
  doubleClickZoom: true,
  boxZoom: true
}).setView([54.7, 25.3], 6);
const baseTiles = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { 
  attribution: 'Â© OpenStreetMap contributors',
  maxZoom: 19
}).addTo(map);
const tileContainer = baseTiles.getContainer();
if (tileContainer) tileContainer.style.transition = 'opacity 1.5s ease';

/* ==================== MARKER ==================== */
const balloonMarker = L.marker([53.9, 27.56], {
  icon: L.divIcon({ className: 'emoji-pin', html: 'ðŸŽˆ', iconSize: [40, 40] })
}).addTo(map);

function clearAnimTimers(marker){
  if(marker._animTimers){
    marker._animTimers.forEach(t=>clearTimeout(t));
    marker._animTimers = [];
  }
}
balloonMarker.on('click', () => {
  const el = balloonMarker.getElement();
  if(!el) return;

  clearAnimTimers(balloonMarker);

  el.style.transition = '';
  el.style.opacity = '1';
  el.innerHTML = 'ðŸ’¥';

  const t1 = setTimeout(() => {
    el.style.transition = 'opacity 1.5s ease';
    el.style.opacity = '0';
  }, 500);

  const t2 = setTimeout(() => {
    el.innerHTML = 'ðŸŽˆ';
    el.style.transition = '';
    el.style.opacity = '0';
    requestAnimationFrame(() => {
      el.style.transition = 'opacity 0.5s ease';
      el.style.opacity = '1';
    });
  }, 4000);

  balloonMarker._animTimers = [t1, t2];
});

/* ==================== UTILS ==================== */
const norm360 = a => (a % 360 + 360) % 360;
const angDiff = (a, b) => { const d = Math.abs(norm360(a) - norm360(b)); return d > 180 ? 360 - d : d; };
const kmToDegrees = km => km / 111;

function hexToRgba(hex, a=1){ 
  const r=parseInt(hex.slice(1,3),16),g=parseInt(hex.slice(3,5),16),b=parseInt(hex.slice(5,7),16); 
  return `rgba(${r}, ${g}, ${b}, ${a})`; 
}
function interp(hex1,hex2,t,a=1){
  const r1=parseInt(hex1.slice(1,3),16),g1=parseInt(hex1.slice(3,5),16),b1=parseInt(hex1.slice(5,7),16);
  const r2=parseInt(hex2.slice(1,3),16),g2=parseInt(hex2.slice(3,5),16),b2=parseInt(hex2.slice(5,7),16);
  const r=Math.round(r1+(r2-r1)*t),g=Math.round(g1+(g2-g1)*t),b=Math.round(b1+(b2-b1)*t);
  return `rgba(${r}, ${g}, ${b}, ${a})`;
}
function getWindColor(speed){
  const {WIND_CALM_THRESHOLD:lo,WIND_MODERATE_THRESHOLD:hi,WIND_COLOR_CALM:c1,WIND_COLOR_MODERATE:c2,WIND_COLOR_STRONG:c3}=CONFIG;
  if(speed<lo) return interp(c1,c2,speed/lo,.95);
  if(speed<hi) return interp(c2,c3,(speed-lo)/(hi-lo),.95);
  return hexToRgba(c3,.95);
}
function poolAll(items, fn, size=4, onProgress){
  size=Math.max(1,Math.floor(size));
  return new Promise(resolve=>{
    const out=new Array(items.length); let i=0,running=0,done=0, total=items.length;
    function bump(){ if(onProgress) onProgress(done, total); }
    function next(){
      while(running<size && i<items.length){
        const idx=i++; running++;
        Promise.resolve(fn(items[idx],idx))
          .then(v=>{out[idx]=v})
          .catch(e=>{console.warn(`Task ${idx} failed:`,e?.message||e); out[idx]=null})
          .finally(()=>{running--; done++; bump(); done===items.length?resolve(out):next()});
      }
    }
    bump();
    next();
  });
}
async function withRetry(fn, tries = 2, delayMs = 250){
  let lastErr;
  for (let i=0; i<tries; i++){
    try {
      return await fn();
    } catch (e){
      if (e && (e.name === 'AbortError' || e.code === 20)) throw e;
      lastErr = e;
      if (i < tries - 1) await new Promise(r => setTimeout(r, delayMs));
    }
  }
  throw lastErr;
}

/* ==================== DAY/NIGHT ==================== */
function updateTileOpacityForDayNight(date, country) {
  const coords = COUNTRY_COORDS[country] || { lat: 54.7, lon: 25.3 };
  const t = SunCalc.getTimes(date, coords.lat, coords.lon);
  const now = date.getTime(), maxDim = CONFIG.NIGHT_OPACITY_MAX/100;
  let dim = 0;
  if (now < t.dawn.getTime()) dim = maxDim;
  else if (now < t.sunrise.getTime()) dim = maxDim * (1 - (now - t.dawn.getTime())/Math.max(1,t.sunrise.getTime()-t.dawn.getTime()));
  else if (now < t.sunset.getTime()) dim = 0;
  else if (now < t.dusk.getTime()) dim = maxDim * ((now - t.sunset.getTime())/Math.max(1,t.dusk.getTime()-t.sunset.getTime()));
  else dim = maxDim;
  baseTiles.setOpacity(1 - dim);
}

/* ==================== API ==================== */
const cache = { wind: new Map(), country: new Map() };

async function fetchCountryFeature(country){
  if(cache.country.has(country)) return cache.country.get(country);
  const url = `https://nominatim.openstreetmap.org/search?format=geojson&limit=1&polygon_geojson=1&polygon_threshold=0.01&country=${encodeURIComponent(country)}`;
  const feature = await withRetry(async () => {
    const res = await fetch(url,{headers:{
      'Accept':'application/geo+json',
      'User-Agent': CONFIG.USER_AGENT
    }});
    if (!res.ok) throw new Error(`Nominatim ${res.status}`);
    const data = await res.json();
    if(!data.features?.length) throw new Error('No polygon for '+country);
    return data.features[0];
  }, 2, 300);
  cache.country.set(country,feature);
  return feature;
}

async function fetchHourlyWindBackupMetNo(lat, lon, signal){
  const url = `https://api.met.no/weatherapi/locationforecast/2.0/compact?lat=${lat}&lon=${lon}`;
  const res = await fetch(url, {
    signal,
    headers: {
      'Accept': 'application/json',
      'User-Agent': CONFIG.USER_AGENT
    }
  });
  if (!res.ok) throw new Error(`met.no ${res.status}`);
  const data = await res.json();
  const series = data?.properties?.timeseries || [];
  if (!series.length) throw new Error('met.no empty');

  const time = [];
  const dir  = [];
  const spd  = [];

  for (const row of series){
    const t = row.time;
    const details = row?.data?.instant?.details || {};
    const d = details.wind_from_direction;
    const s = details.wind_speed;
    if (typeof d === 'number' && typeof s === 'number'){
      time.push(new Date(t));
      dir.push(d);
      spd.push(s * 3.6);
    }
  }
  if (!time.length) throw new Error('met.no: no usable wind points');
  return { time, dir, spd };
}

async function fetchHourlyWind(lat,lon,signal){
  const url = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}` +
              `&hourly=wind_speed_10m,wind_direction_10m&forecast_days=${CONFIG.FORECAST_DAYS}` +
              `&timezone=auto&windspeed_unit=kmh`;

  try {
    return await withRetry(async () => {
      const res = await fetch(url,{signal});
      if (!res.ok) throw new Error(`Open-Meteo ${res.status}`);
      const data = await res.json();
      if (!data?.hourly?.time || !data.hourly.wind_speed_10m || !data.hourly.wind_direction_10m){
        throw new Error('Open-Meteo payload missing');
      }
      return {
        time: data.hourly.time.map(t=>new Date(t)),
        dir:  data.hourly.wind_direction_10m,
        spd:  data.hourly.wind_speed_10m
      };
    }, 2, 300);
  } catch (e){
    console.warn('Open-Meteo failed, trying met.no backup:', e?.message || e);
    return await withRetry(
      () => fetchHourlyWindBackupMetNo(lat, lon, signal),
      2,
      300
    );
  }
}

function snapKey(v){ return (Math.round(v*50)/50).toFixed(2); }
async function cachedWind(lat,lon,signal){
  const key=`${snapKey(lat)},${snapKey(lon)}`;
  if(cache.wind.has(key)) return cache.wind.get(key);
  const val=await fetchHourlyWind(lat,lon,signal);
  cache.wind.set(key,val);
  return val;
}

/* ==================== GEOMETRY ==================== */
function simplifyFeature(feat){
  return turf.simplify(feat,{tolerance:kmToDegrees(CONFIG.SIMPLIFY_TOLERANCE_KM),highQuality:false,mutate:false});
}
function extractOuterRings(feat){
  const g=feat.geometry;
  if(g.type==='Polygon')return [g.coordinates[0]];
  if(g.type==='MultiPolygon')return g.coordinates.map(p=>p[0]);
  return [];
}
function resampleForDrawing(ring){
  const line=turf.lineString(ring);
  const len=turf.length(line,{units:'kilometers'});
  const n=Math.max(20,Math.floor(len/CONFIG.DRAW_STEP_KM));
  const coords=[];
  for(let i=0;i<=n;i++){
    const p=turf.along(line,(i/n)*len,{units:'kilometers'});
    coords.push([p.geometry.coordinates[1],p.geometry.coordinates[0]]);
  }
  return coords;
}
function sampleForWind(ring){
  const line=turf.lineString(ring);
  const len=turf.length(line,{units:'kilometers'});
  const n=Math.max(6,Math.floor(len/CONFIG.SAMPLE_FOR_WIND_KM));
  const pts=[]; const isCW=turf.booleanClockwise(ring);
  for(let i=0;i<n;i++){
    const s=(i/n)*len,e=((i+1)/n)*len;
    const A=turf.along(line,s,{units:'kilometers'});
    const B=turf.along(line,e,{units:'kilometers'});
    const M=turf.midpoint(A,B);
    const bearing=turf.bearing(A,B);
    const outward=norm360(bearing+(isCW?-90:+90));
    pts.push({a:A.geometry.coordinates,b:B.geometry.coordinates,m:M.geometry.coordinates,bearing,outward});
  }
  return pts;
}

/* ==================== STATE ==================== */
const state = {
  feature:null, rings:[], windSamples:[], timeIndex:0,
  borderLayer:null, redLayerGroup:null, currentAbort:null, currentCountry:'Lithuania'
};

/* ==================== RENDERING ==================== */
function clearLayers(){ 
  if(state.redLayerGroup){state.redLayerGroup.remove();state.redLayerGroup=null} 
  if(state.borderLayer){state.borderLayer.remove();state.borderLayer=null} 
}

function drawCountryAndBorder(){
  const ringLayers = state.rings.map(r=> L.polyline(resampleForDrawing(r),{color:'#101010',weight:4,opacity:.95}) );
  state.borderLayer = L.layerGroup(ringLayers).addTo(map);
  const all = ringLayers.flatMap(l=>l.getLatLngs()).flat();
  if (all.length) map.fitBounds(L.latLngBounds(all),{padding:[18,18]});
}

function computeInflowFlags(idx){
  return state.windSamples.map(s=>{
    const d=s.wind?.dir[idx]; if(d==null) return false;
    return angDiff(d,s.outward) <= CONFIG.INFLOW_ANGLE_THRESHOLD;
  });
}

function showTooltipAt(x,y,html){
  elements.windTooltip.innerHTML = html;
  elements.windTooltip.style.display='block';
  elements.windTooltip.style.left=(x+10)+'px';
  elements.windTooltip.style.top=(y-28)+'px';
}
function hideTooltip(){ elements.windTooltip.style.display='none'; }

function nearestSampleToLatLng(latlng, indices){
  const lon = latlng.lng, lat = latlng.lat;
  let best=null, bestD=Infinity, bestIdx=-1;
  for(const si of indices){
    const s = state.windSamples[si]; if(!s) continue;
    const dx = lon - s.m[0], dy = lat - s.m[1];
    const d = dx*dx + dy*dy;
    if(d < bestD){ bestD=d; best=s; bestIdx=si; }
  }
  return { sample: best, idx: bestIdx };
}

function drawRedSegmentsFromInflow(inflowFlags){
  if(state.redLayerGroup) state.redLayerGroup.remove();

  const polylines=[]; const metaIdx=[]; let cur=[], curIdxs=[];
  for(let i=0;i<state.windSamples.length;i++){
    if(inflowFlags[i]){
      const s=state.windSamples[i];
      if(!cur.length) cur.push([s.a[1],s.a[0]]);
      cur.push([s.b[1],s.b[0]]);
      curIdxs.push(i);
    }else if(cur.length){
      polylines.push(cur); metaIdx.push(curIdxs); cur=[]; curIdxs=[];
    }
  }
  if(cur.length){ polylines.push(cur); metaIdx.push(curIdxs); }

  const layers=[];
  polylines.forEach((coords,chunkIdx)=>{
    const indices = metaIdx[chunkIdx];

    const onHover = (e) => {
      const latlng = e.latlng || (e.originalEvent ? map.mouseEventToLatLng(e.originalEvent) : null);
      if(!latlng) return hideTooltip();
      const { sample } = nearestSampleToLatLng(latlng, indices);
      if(!sample || !sample.wind) return hideTooltip();
      const spd = sample.wind.spd[state.timeIndex];
      if(spd == null) return hideTooltip();
      const pt = map.latLngToContainerPoint([latlng.lat, latlng.lng]);
      showTooltipAt(pt.x, pt.y, `inflow | ${Math.round(spd)} km/h`);
    };

    const hit = L.polyline(coords,{color:'#000',opacity:0,weight:40,interactive:true,bubblingMouseEvents:false})
      .on('mousemove', onHover)
      .on('mouseout', hideTooltip)
      .on('touchstart', onHover)
      .on('touchmove', onHover)
      .on('touchend', hideTooltip)
      .on('touchcancel', hideTooltip);

    const glow = L.polyline(coords,{color:hexToRgba('#ff3b30',.45),weight:18,opacity:.7,interactive:false});
    const core = L.polyline(coords,{color:'#ff3b30',weight:10,opacity:.97,lineCap:'round',interactive:false});

    layers.push(glow, core, hit);
  });

  state.redLayerGroup = L.layerGroup(layers).addTo(map);
}

/* ==================== PARTICLES ==================== */
const ParticleLayer = L.Layer.extend({
  onAdd(map){
    this._map = map;
    this._canvas = L.DomUtil.create('canvas','');
    const pane = map.getPanes().overlayPane;
    this._canvas.style.position='absolute';
    this._canvas.style.pointerEvents='none';
    this._canvas.style.zIndex='3';
    pane.appendChild(this._canvas);
    map.on('move zoom resize', this._reset, this);
    this._reset();

    const onVis = () => {
      if (document.hidden){ if(this._raf) cancelAnimationFrame(this._raf); }
      else { this._animate(); }
    };
    this._onVis = onVis;
    document.addEventListener('visibilitychange', onVis);

    this._animate();
  },
  onRemove(map){
    map.off('move zoom resize', this._reset, this);
    L.DomUtil.remove(this._canvas);
    if(this._raf) cancelAnimationFrame(this._raf);
    if(this._onVis) document.removeEventListener('visibilitychange', this._onVis);
    hideTooltip();
  },
  _reset(){
    const size=this._map.getSize();
    const ratio = window.devicePixelRatio || 1;

    this._canvas.width  = Math.round(size.x * ratio);
    this._canvas.height = Math.round(size.y * ratio);
    this._canvas.style.width  = size.x + 'px';
    this._canvas.style.height = size.y + 'px';

    const ctx = this._canvas.getContext('2d');
    ctx.setTransform(ratio, 0, 0, ratio, 0, 0);

    if(this._particles){
      this._particles.forEach(p=>{
        const pt=this._map.latLngToLayerPoint([p.lat,p.lon]);
        p.x=pt.x; p.y=pt.y;
      });
    }
  },
  setParticles(p){ this._particles=p; },
  setVectorGetter(fn){ this._vectorAt=fn; },
  _animate(){
    const ctx=this._canvas.getContext('2d');

    ctx.save();
    ctx.setTransform(1,0,0,1,0,0);
    ctx.clearRect(0,0,this._canvas.width,this._canvas.height);
    ctx.restore();

    const parts=this._particles||[];
    ctx.globalAlpha=CONFIG.PARTICLE_GLOW;
    ctx.lineWidth=CONFIG.PARTICLE_LINE_WIDTH;
    parts.forEach(p=>{
      const pt=this._map.latLngToLayerPoint([p.lat,p.lon]);
      if(p.x==null){p.x=pt.x; p.y=pt.y;}
      const v=this._vectorAt?this._vectorAt(p.lat,p.lon):{vx:0,vy:0,speed:0};
      ctx.strokeStyle=getWindColor(v.speed||0);
      ctx.beginPath(); ctx.moveTo(p.x,p.y);
      p.x+=v.vx; p.y+=v.vy;
      ctx.lineTo(p.x,p.y); ctx.stroke();
      p.life-=1;
      const size=this._map.getSize();
      if(p.life<=0||p.x<0||p.y<0||p.x>size.x||p.y>size.y){
        p.x=pt.x; p.y=pt.y;
        p.life = CONFIG.PARTICLE_LIFE_MIN + Math.random()*(CONFIG.PARTICLE_LIFE_MAX - CONFIG.PARTICLE_LIFE_MIN);
      }
    });
    this._raf=requestAnimationFrame(this._animate.bind(this));
  }
});
const particleLayer = new ParticleLayer().addTo(map);

function initParticles(){
  const seeds = state.windSamples.map(s=>({lat:s.m[1],lon:s.m[0]}));
  const list=[]; const z=map.getZoom(); const perSeed=Math.max(6,Math.round(6+(z-4)*0.6));
  seeds.forEach(seed=>{
    for(let i=0;i<perSeed;i++){
      list.push({
        lat: seed.lat+(Math.random()-.5)*0.05,
        lon: seed.lon+(Math.random()-.5)*0.05,
        life: CONFIG.PARTICLE_LIFE_MIN + Math.random()*(CONFIG.PARTICLE_LIFE_MAX - CONFIG.PARTICLE_LIFE_MIN),
        x: null,
        y: null
      });
    }
  });
  particleLayer.setParticles(list);
}
function getVectorAtSelectedHour(lat,lon){
  let best=null,bestD=Infinity;
  for(const s of state.windSamples){
    const dx=lon-s.m[0], dy=lat-s.m[1], d=dx*dx + dy*dy;
    if(d<bestD){bestD=d; best=s;}
  }
  if(!best||!best.wind) return {vx:0,vy:0,speed:0};
  const dirFrom=best.wind.dir[state.timeIndex], spd=best.wind.spd[state.timeIndex];
  if(dirFrom == null || spd == null) return {vx:0,vy:0,speed:0};
  const dirTo=norm360(dirFrom+180)*Math.PI/180;
  const v=Math.min(CONFIG.SPEED_CAP, CONFIG.SPEED_BIAS + spd*CONFIG.SPEED_SCALE);
  return {vx:Math.sin(dirTo)*v, vy:-Math.cos(dirTo)*v, speed:spd};
}
particleLayer.setVectorGetter((lat,lon)=>getVectorAtSelectedHour(lat,lon));

/* ==================== TIME ==================== */
function buildDateDropdownFromData(firstWind){
  elements.dateSelect.innerHTML = '';
  const fmt = new Intl.DateTimeFormat('en-CA',{year:'numeric',month:'2-digit',day:'2-digit'});
  const days = new Map();
  for (const dt of firstWind.time){
    const mid = +new Date(dt.getFullYear(), dt.getMonth(), dt.getDate());
    if (!days.has(mid)) days.set(mid, fmt.format(new Date(mid)));
    if (days.size >= CONFIG.FORECAST_DAYS) break;
  }
  for (const [mid,label] of days){
    const opt = document.createElement('option');
    opt.value = String(mid);
    opt.textContent = label;
    elements.dateSelect.appendChild(opt);
  }
}

function selectHourIndex(){
  const first=state.windSamples.find(s=>s.wind)?.wind; if(!first) return 0;
  const activeLocalMidnight = Number(elements.dateSelect.value);
  const target = new Date(activeLocalMidnight);
  target.setHours(+elements.hourSlider.value,0,0,0);
  let bestIdx=0,bestDelta=Infinity;
  for(let i=0;i<first.time.length;i++){
    const dt=Math.abs(first.time[i]-target);
    if(dt<bestDelta){bestDelta=dt; bestIdx=i; if(dt===0)break;}
  }
  return bestIdx;
}
function applyTimeSelection(){
  state.timeIndex=selectHourIndex();
  const first=state.windSamples.find(s=>s.wind)?.wind;
  const ts = first?.time?.[state.timeIndex] || new Date();
  const hh=String(ts.getHours()).padStart(2,'0');
  const mm=String(ts.getMinutes()).padStart(2,'0');
  elements.timeDisplay.textContent=`${hh}:${mm}`;

  updateTileOpacityForDayNight(ts, state.currentCountry);

  const inflowFlags=computeInflowFlags(state.timeIndex);
  drawRedSegmentsFromInflow(inflowFlags);
  checkLiveView();
}
function checkLiveView(){
  const now=new Date();
  const localMidnight=+new Date(now.getFullYear(),now.getMonth(),now.getDate());
  const isLive=Number(elements.dateSelect.value)===localMidnight && Number(elements.hourSlider.value)===now.getHours();
  if(isLive){elements.liveBtn.classList.add('live-active');elements.liveBtn.textContent='â— LIVE';}
  else{elements.liveBtn.classList.remove('live-active');elements.liveBtn.textContent='Live view';}
}
function snapToLive(){
  const now=new Date();
  elements.dateSelect.value=String(+new Date(now.getFullYear(),now.getMonth(),now.getDate()));
  elements.hourSlider.value=now.getHours();
  applyTimeSelection();
}

/* ==================== LOADING BAR HELPERS ==================== */
function setLoadProgressPct(pct){
  const v = Math.max(0, Math.min(100, Math.round(pct)));
  requestAnimationFrame(() => {
    elements.loadingBar.style.width = v + '%';
  });
}

/* ==================== LOADING ==================== */
function showLoading(show){
  const container = elements.sliderContainer;
  if(show){
    container.classList.remove('loaded');
    container.classList.add('loading');
    setLoadProgressPct(0);
  }else{
    setLoadProgressPct(100);
    container.classList.remove('loading');
    container.classList.add('loaded');
  }

  elements.countrySelect.disabled = show;
  elements.dateSelect.disabled = show;
  elements.hourSlider.disabled = show;
  elements.liveBtn.disabled = show;
}

/* ==================== OFFLINE HINT ==================== */
function showOfflineHint(msg){
  const el = elements.offlineHint;
  el.textContent = msg || 'You appear to be offline or the data service is unavailable. Showing cached data if possible.';
  el.style.display = 'block';
  clearTimeout(showOfflineHint._t);
  showOfflineHint._t = setTimeout(()=>{ el.style.display='none'; }, 6000);
}

/* ==================== MAIN ==================== */
async function loadCountry(country, preserveTime = false){
  if(state.currentAbort) state.currentAbort.abort();
  state.currentAbort=new AbortController(); const {signal}=state.currentAbort;

  // Store current selection before loading
  const savedDate = preserveTime ? elements.dateSelect.value : null;
  const savedHour = preserveTime ? elements.hourSlider.value : null;

  showLoading(true);
  clearLayers(); state.currentCountry=country;

  try{
    setLoadProgressPct(5);
    state.feature=simplifyFeature(await fetchCountryFeature(country));
    setLoadProgressPct(20);

    state.rings=extractOuterRings(state.feature);
    drawCountryAndBorder();
    setLoadProgressPct(28);

    state.windSamples = state.rings.flatMap(r=>sampleForWind(r));
    setLoadProgressPct(30);

    const total = state.windSamples.length || 1;

    const winds = await poolAll(
      state.windSamples,
      (s)=>cachedWind(s.m[1],s.m[0],signal),
      CONFIG.CONCURRENCY,
      (completed)=>{
        const pct = 30 + (completed/total) * 70;
        setLoadProgressPct(pct);
      }
    );

    state.windSamples.forEach((s,i)=>{ s.wind=winds[i]; });

    if (!state.windSamples.some(s=>s.wind)){
      const c = COUNTRY_COORDS[country] || { lat: 54.7, lon: 25.3 };
      const fallback = await cachedWind(c.lat, c.lon, signal);
      if (state.windSamples[0]) state.windSamples[0].wind = fallback;
      showOfflineHint('Wind data partially unavailable. Showing limited timeline.');
    }

    const first = state.windSamples.find(s=>s.wind)?.wind;
    if (first){
      buildDateDropdownFromData(first);
      
      // Restore previous selection if preserving time
      if (preserveTime && savedDate && savedHour) {
        // Check if saved date still exists in new dropdown
        const dateExists = Array.from(elements.dateSelect.options).some(opt => opt.value === savedDate);
        if (dateExists) {
          elements.dateSelect.value = savedDate;
          elements.hourSlider.value = savedHour;
        } else {
          // If saved date doesn't exist, snap to live
          snapToLive();
        }
      } else {
        // First load, snap to live
        snapToLive();
      }
    } else {
      elements.dateSelect.innerHTML = '';
      showOfflineHint('No wind timeline available right now.');
    }

    initParticles();
    applyTimeSelection();
  }catch(e){
    if(e.name!=='AbortError'){
      console.error('Error loading country:',e);
      showOfflineHint('Network or API error. Map might be incomplete; please retry.');
    }
  } finally {
    showLoading(false);
  }
}

/* ==================== UI INIT ==================== */
function setInitialPanelState(){
  if(window.innerWidth<=768){ 
    elements.infoPanel.classList.add('collapsed'); 
    elements.infoToggle.setAttribute('aria-expanded','false'); 
  } else { 
    elements.infoPanel.classList.remove('collapsed'); 
    elements.infoToggle.setAttribute('aria-expanded','true'); 
  }
}

function initControls(){
  elements.dateSelect.innerHTML = '';
  elements.hourSlider.value = new Date().getHours();

  elements.dateSelect.onchange=applyTimeSelection;
  elements.hourSlider.oninput=applyTimeSelection;
  elements.liveBtn.onclick=snapToLive;
  elements.countrySelect.onchange=async()=>{ await loadCountry(elements.countrySelect.value, true); };
  
  const toggleInfo = () => { 
    elements.infoPanel.classList.toggle('collapsed'); 
    elements.infoToggle.setAttribute('aria-expanded', String(!elements.infoPanel.classList.contains('collapsed'))); 
  };
  elements.infoToggle.onclick = toggleInfo;
  elements.infoToggle.onkeydown = (e) => { if(e.key === 'Enter' || e.key === ' ') { e.preventDefault(); toggleInfo(); } };
  
  const toggleDisclaimer = () => { 
    elements.disclaimer.classList.toggle('open'); 
    elements.disclaimer.setAttribute('aria-expanded', String(elements.disclaimer.classList.contains('open'))); 
  };
  elements.disclaimer.onclick = toggleDisclaimer;
  elements.disclaimer.onkeydown = (e) => { if(e.key === 'Enter' || e.key === ' ') { e.preventDefault(); toggleDisclaimer(); } };
}

/* ==================== START ==================== */
setInitialPanelState();
window.addEventListener('resize', setInitialPanelState);
initControls();
await loadCountry(elements.countrySelect.value);

})();
</script>
</body>
</html>
